<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Puter.js Bridge</title>
    <script src="https://js.puter.com/v2/"></script>
</head>
<body>
    <script>
        // Store the auth resolver to complete authentication later
        window.__puterAuthResolver = null;
        
        // Override Puter's auth methods to handle mobile limitations
        const originalSignIn = puter.auth.signIn;
        puter.auth.signIn = function(options = {}) {
            return new Promise((resolve, reject) => {
                try {
                    console.log("Mobile: Overriding signIn to handle popup authentication");
                    
                    // Store the resolver to be called later when authentication completes
                    window.__puterAuthResolver = resolve;
                    
                    // Call the original method which will open a popup window for authentication
                    originalSignIn.call(puter.auth, options);
                    
                    // We don't return anything here - the resolver will be called later
                    // when authentication completes via the popup window or redirect
                } catch (error) {
                    console.error("Error in signIn override:", error);
                    reject(error);
                }
            });
        };
        
        // Add event listeners for Android to trigger auth completion
        window.AndroidInterface = {
            onAuthSuccess: function(userJson) {
                console.log("Android reports auth success:", userJson);
                if (window.__puterAuthResolver) {
                    try {
                        const user = JSON.parse(userJson);
                        window.__puterAuthResolver(user);
                        window.__puterAuthResolver = null;
                    } catch (e) {
                        console.error("Error parsing user JSON:", e);
                        // If parsing fails, resolve with null to indicate failure
                        window.__puterAuthResolver(null);
                        window.__puterAuthResolver = null;
                    }
                }
            },
            onAuthError: function(errorMessage) {
                console.error("Android reports auth error:", errorMessage);
                if (window.__puterAuthResolver) {
                    window.__puterAuthResolver(null);
                    window.__puterAuthResolver = null;
                }
            }
        };
        
        // Initialize Puter.js
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Puter.js bridge initialized");
            
            // Add event listeners for auth events
            puter.auth.on('signin', function(user) {
                console.log("User signed in:", user);
                if (window.AndroidInterface && window.AndroidInterface.onAuthSuccess) {
                    window.AndroidInterface.onAuthSuccess(JSON.stringify(user));
                }
            });
            
            puter.auth.on('signout', function() {
                console.log("User signed out");
            });
            
            // Listen for postMessage events from popup windows
            window.addEventListener("message", function(event) {
                console.log("Received message from popup:", event.data, "from origin:", event.origin);
                
                // Check if this is an authentication completion message
                if (event.data && event.data.type === "PUTER_AUTH_COMPLETE") {
                    console.log("Authentication completed with token:", event.data.token);
                    
                    // Store the token in localStorage for future use
                    if (event.data.token) {
                        localStorage.setItem('puter_auth_token', event.data.token);
                        
                        // Call the Android interface to notify of successful authentication
                        if (window.AndroidInterface) {
                            window.AndroidInterface.onAuthSuccess(JSON.stringify({
                                token: event.data.token,
                                authenticated: true
                            }));
                        }
                    }
                }
                
                // Handle puter authentication callback messages
                if (event.data && typeof event.data === 'object') {
                    if (event.data.type === 'puter-auth-callback' || 
                        event.data.type === 'auth-callback' || 
                        (event.data.token && event.data.user)) {
                        console.log("Detected puter auth completion message:", event.data);
                        
                        // Store the token in localStorage
                        if (event.data.token) {
                            localStorage.setItem('puter_auth_token', event.data.token);
                        }
                        
                        // Notify Android of authentication completion
                        if (window.AndroidInterface && window.AndroidInterface.onAuthSuccess) {
                            window.AndroidInterface.onAuthSuccess(JSON.stringify(event.data));
                        }
                        
                        // Also resolve the stored promise if available
                        if (window.__puterAuthResolver) {
                            window.__puterAuthResolver(event.data.user || event.data);
                            window.__puterAuthResolver = null;
                        }
                    }
                }
                
                // Handle the specific message format that puter.js uses for auth completion
                if (event.data && typeof event.data === 'object' && event.data.cmd === 'puter.auth.callback') {
                    console.log("Received puter auth callback:", event.data);
                    
                    if (event.data.token) {
                        localStorage.setItem('puter_auth_token', event.data.token);
                        
                        if (window.AndroidInterface && window.AndroidInterface.onAuthSuccess) {
                            window.AndroidInterface.onAuthSuccess(JSON.stringify({
                                token: event.data.token,
                                authenticated: true
                            }));
                        }
                        
                        // Resolve the stored promise if available
                        if (window.__puterAuthResolver) {
                            window.__puterAuthResolver({token: event.data.token});
                            window.__puterAuthResolver = null;
                        }
                    }
                }
            });
            
            // Also set up a global handler for puter authentication callbacks
            // This is important for the authentication flow to work properly
            if (window.puter && window.puter.auth) {
                // Ensure the postMessage listener is properly set up
                console.log("Puter.js is ready and available");
            } else {
                // Wait for puter to be ready
                console.log("Waiting for puter.js to be ready");
            }
            
            // Additional check for existing auth token in localStorage
            const existingToken = localStorage.getItem('puter_auth_token');
            if (existingToken) {
                console.log("Found existing auth token in localStorage");
            }
        });
        
        // Bridge functions to interact with Puter.js from native Android code
        async function puterChat(query) {
            try {
                const response = await puter.ai.chat({
                    messages: [{ role: 'user', content: query }]
                });
                return response;
            } catch (error) {
                console.error('Chat error:', error);
                throw error;
            }
        }

        async function puterChatStream(query, onChunkCallback) {
            try {
                const response = await puter.ai.chat({
                    messages: [{ role: 'user', content: query }],
                    stream: true
                });
                
                let fullText = '';
                for await (const chunk of response) {
                    if (chunk?.text) {
                        fullText += chunk.text;
                        if (onChunkCallback) {
                            onChunkCallback(chunk.text);
                        }
                    }
                }
                return fullText;
            } catch (error) {
                console.error('Chat stream error:', error);
                throw error;
            }
        }

        async function puterTxt2Img(prompt, options = {}) {
            try {
                const response = await puter.ai.txt2img(prompt, options);
                return response;
            } catch (error) {
                console.error('Txt2Img error:', error);
                throw error;
            }
        }

        async function puterImg2Txt(imageData) {
            try {
                // Assuming image is a base64 string or file object
                const response = await puter.ai.img2txt(imageData);
                return response;
            } catch (error) {
                console.error('Img2Txt error:', error);
                throw error;
            }
        }

        async function puterTxt2Speech(text, options = {}) {
            try {
                const response = await puter.ai.txt2speech(text, options);
                return response;
            } catch (error) {
                console.error('Txt2Speech error:', error);
                throw error;
            }
        }

        async function puterKvGet(key) {
            try {
                const response = await puter.kv.get(key);
                return response;
            } catch (error) {
                console.error('KV Get error:', error);
                throw error;
            }
        }

        async function puterKvSet(key, value) {
            try {
                const response = await puter.kv.set(key, value);
                return response;
            } catch (error) {
                console.error('KV Set error:', error);
                throw error;
            }
        }

        async function puterKvDel(key) {
            try {
                const response = await puter.kv.del(key);
                return response;
            } catch (error) {
                console.error('KV Del error:', error);
                throw error;
            }
        }

        async function puterKvList(pattern = '*', returnValues = false) {
            try {
                const response = await puter.kv.list(pattern, returnValues);
                return response;
            } catch (error) {
                console.error('KV List error:', error);
                throw error;
            }
        }

        async function puterKvIncr(key, amount = 1) {
            try {
                const response = await puter.kv.incr(key, amount);
                return response;
            } catch (error) {
                console.error('KV Incr error:', error);
                throw error;
            }
        }

        async function puterKvDecr(key, amount = 1) {
            try {
                const response = await puter.kv.decr(key, amount);
                return response;
            } catch (error) {
                console.error('KV Decr error:', error);
                throw error;
            }
        }

        async function puterKvFlush() {
            try {
                const response = await puter.kv.flush();
                return response;
            } catch (error) {
                console.error('KV Flush error:', error);
                throw error;
            }
        }

        // File System functions
        async function puterFsWrite(path, data, options = {}) {
            try {
                const response = await puter.fs.write(path, data, options);
                return response;
            } catch (error) {
                console.error('FS Write error:', error);
                throw error;
            }
        }

        async function puterFsRead(path, options = {}) {
            try {
                const response = await puter.fs.read(path, options);
                return response;
            } catch (error) {
                console.error('FS Read error:', error);
                throw error;
            }
        }

        async function puterFsMkdir(path, options = {}) {
            try {
                const response = await puter.fs.mkdir(path, options);
                return response;
            } catch (error) {
                console.error('FS Mkdir error:', error);
                throw error;
            }
        }

        async function puterFsReaddir(path) {
            try {
                const response = await puter.fs.readdir(path);
                return response;
            } catch (error) {
                console.error('FS Readdir error:', error);
                throw error;
            }
        }

        async function puterFsDelete(path, options = {}) {
            try {
                const response = await puter.fs.delete(path, options);
                return response;
            } catch (error) {
                console.error('FS Delete error:', error);
                throw error;
            }
        }

        async function puterFsMove(source, destination, options = {}) {
            try {
                const response = await puter.fs.move(source, destination, options);
                return response;
            } catch (error) {
                console.error('FS Move error:', error);
                throw error;
            }
        }

        async function puterFsCopy(source, destination, options = {}) {
            try {
                const response = await puter.fs.copy(source, destination, options);
                return response;
            } catch (error) {
                console.error('FS Copy error:', error);
                throw error;
            }
        }

        async function puterFsRename(path, newName) {
            try {
                const response = await puter.fs.rename(path, newName);
                return response;
            } catch (error) {
                console.error('FS Rename error:', error);
                throw error;
            }
        }

        async function puterFsStat(path) {
            try {
                const response = await puter.fs.stat(path);
                return response;
            } catch (error) {
                console.error('FS Stat error:', error);
                throw error;
            }
        }

        async function puterFsSpace() {
            try {
                const response = await puter.fs.space();
                return response;
            } catch (error) {
                console.error('FS Space error:', error);
                throw error;
            }
        }

        // Authentication functions - simplified since authentication is handled via popup
        async function puterAuthSignOut() {
            try {
                const response = await puter.auth.signOut();
                return response;
            } catch (error) {
                console.error('Auth Sign Out error:', error);
                throw error;
            }
        }

        function puterAuthIsSignedIn() {
            try {
                return puter.auth.isSignedIn();
            } catch (error) {
                console.error('Auth Check error:', error);
                return false;
            }
        }

        async function puterAuthGetUser() {
            try {
                const response = await puter.auth.getUser();
                return response;
            } catch (error) {
                console.error('Get User error:', error);
                throw error;
            }
        }
        
        // Function to handle authentication completion from native side
        window.handleAuthCompletion = function(token) {
            console.log("Handling authentication completion with token:", token);
            
            // Store the token in localStorage for future use
            if (token) {
                localStorage.setItem('puter_auth_token', token);
                
                // Set the auth token in the puter instance
                puter.setAuthToken(token);
                
                // Call the Android interface to notify of successful authentication
                if (window.AndroidInterface) {
                    window.AndroidInterface.onAuthSuccess(JSON.stringify({
                        token: token,
                        authenticated: true
                    }));
                }
                
                // Also resolve the stored promise if available
                if (window.__puterAuthResolver) {
                    window.__puterAuthResolver({token: token, authenticated: true});
                    window.__puterAuthResolver = null;
                }
                
                console.log("Authentication completed successfully");
            } else {
                console.error("No token provided for authentication completion");
                
                // Call the Android interface to notify of authentication failure
                if (window.AndroidInterface) {
                    window.AndroidInterface.onAuthError("No token provided");
                }
                
                // Reject the stored promise if available
                if (window.__puterAuthResolver) {
                    window.__puterAuthResolver(null);
                    window.__puterAuthResolver = null;
                }
            }
        };

        // Ready indicator
        window.puterServiceReady = true;
        
        console.log("Puter.js bridge ready");
    </script>
</body>
</html>